# clean architecture with typescript

## 1章 バッドメソッド

### 密結合、疎結合の判断基準

そのコードを修正するときに、多くのコンポーネントからの情報（知識）が必要なものほど密結合になる。

### データを直接読み書きする

データを直接読み書きするのはあぶない、ここでいうデータとはglobalデータ。

これを改善するためにはクラスかして、その中にメソッドを作ること。

### 責務が複数存在している

関数の中に、その関数の責務でないものまで入っている。
その場合もクラスを用意してメソッドを叩くようにする。

### 関数に書かれたコードが知識として露出される

関数の引数に対して処理が複数ある。

インターフェースの活用で対応する。

### 知識を利用する方向性（依存関係の方向性）

抽象度の高いインターフェースを持つ関数の実装では、抽象度が本来より低い実装に依存するというのは好ましくない。
せっかくの抽象度の高さが意味をなくす。

抽象的な存在よりも、機能という具象的な存在が、自分自身で知識を持っているべき。
抽象化してものを機能に分割する。

### まとめ

コードに書かれているファイル名、ディレクトリ構造、データ形式などは全て知識。
これらの知識が不必要に露出されると技術的負債が蓄積されます。必要最小限の露出に止めるようにする。
このとき露出する知識として、インターフェースなどを活用する。

適切なインターフェース定義とJSDocやJsonSchemeのようなスキーマ定義をしっかりとする。

## 2章 ドメイン

## ドメインおよびドメイン知識とは

何かオンラインサービス架するときには、それまで手作業でやっていた作業をオンライン化するための一般知識

ドメイン知識をそのままコードとして表現することで、これを「ビジネスロジックを実装」「ドメインロジックを実装する」などと呼ぶ。

それらドメインロジックからDBやwebフロントエンドなどにつなぐ。

- entity/valueオブジェクト
- repositoryパターン （ストレージとロジックの間に入るもの）
- レイヤードアーキテクチャー
  - プレゼンテーション層
  - アプリケーション層
  - サービス層
  - ドメイン層
  - インフラ層
  - 腐敗防止層

## 3章 SOLID原則

- Single Responsibility Principle: 単一責任の原則
- Open/closed principle: オープン/クロースドの原則
- Liskov substitution principle: リスコフの置換原則
- Interface segregation principle: インターフェース分離の原則
- Dependency inversion principle: 依存性逆転の原則

### Single Responsibility Principle: 単一責任の原則

あるモジュールやクラスや関数などを改修する理由はたった1つになるようにしましょうというもの。
実際には1つのアクターに対して単一責任というべきです。
アクターとは大抵の場合は、人間をさす。例えばWebサービスにアクセスするユーザーや、そのサービスを運営するためのオペレータや、オペレータよりも上位の権限を持つ管理者など。
アクターには自動処理、概念、機会などといった人間以外も含まれます。

大雑把にいうと、あるっクラスがユーザーとオペレータと管理者向けの機能を全部持っていると複雑すぎるからやっちゃダメだから、単一のアクターに対して機能提供できるように分割しましょうということです。

### Open/closed principle: オープン/クロースドの原則

オープンにするのは、拡張に対して。クローズドにするのは、修正に対して。
修正をするなということではなく、追加機能の為に責任を修正すべきではない。ということ。
では機能追加はどうすればいいのか？
拡張は修正とは異なる。何かしらのフックポイントを用意した上で、そのフックに新機能を追加するような仕組み。

インターフェースを用いたやり方、イベント駆動やオブサーバーパターンを用いたやり方や、プラグイン機構などがあります。

あるいは移譲を用いて、クラスをさらに包み込むようなクラスを作成して、そのクラスは元のクラスより多くの機能を提供する。

- すでにあるものには悪影響を与えにくい
- 新機能はガシガシ追加していきたいが拡張なら遠慮する必要はない

### Liskov substitution principle: リスコフの置換原則

- Tは仕様書
- Sはそれの実装

と考えるとき、S型のオブジェクトは置換可能でなければならない。

### Interface segregation principle: インターフェース分離の原則

インターフェースとは、抽象クラス、基底クラス、ダックタイピング的なものを全て含めたインターフェースとしての働きをもつ全て。

インターフェースは複雑にするといけないので、分離できるものは分離しましょうという原則。

### Dependency inversion principle: 依存性逆転の原則

設計上望ましい依存の方向性と、素直に実装しようとした時の方向性は逆転しちゃうので、そこをテクニックでカバーして逆転させると実はすっきりと望ましい設計通りに実装できる。

AというモジュールがBというモジュールを読み込む場合はAはBに依存していると言います。

望ましい依存の仕方は

- 双方向依存しない
- 依存関係が循環しない
- 必要以上の情報を受け取らず疎結合にする

抽象と詳細はアーキテクチャー本で登場する呼び方。
抽象は共通点を束ねたものであるが、それだけではなく、詳細からエッセンスだけを抜き出したものと言える。

- 詳細に対して依存してはいけない

例

```
class GreatHardware {
    somethingGreat(){
        // 何かハードウェア依存の処理を行う
    }
}

class LowLayer {
    hardware:GreatHardware;
    constructor(){
        this.hardware = new GreatHardware();
    }

    doHoge() {
        this.hardware.somethingGreat();
    }
}
```
この構成には問題がある。クラスLowLayerが、実際のハードウェアがないと動かないクラスGreatHardwareを直接newしてしまっているため、実際のハードウェアがないとテストできない。

これを解決するには、下記の構成例2のように「DI(依存性注入)」を使うことができる。ここでは、LowLayerのコンストラクタからGreatHardwareのインスタンスを注入している。これによりインターフェースIGreatHardwareを実装したモックをLowLayerのコンストラクタに注入すれば実際のハードウェアがなくてもLowLayerのテストができるということになる。

```
interface IGreatHardware {
    somethingGreat();
}

class GreatHardwareImpl implements IGreatHardware {
    somethingGreat(){
        // 何かハードウェア依存の処理を行う
    }
}

class LowLayer {
    hardware:IGreatHardware;
    constructor(hardware:IGreatHardware){
        this.hardware = hardware;
    }

    doHoge() {
        this.hardware.somethingGreat();
    }
}
```

コンポーネントの中に他のクラスをnewすると単体テストができなくなる、
しかしそうするとどこでnewすればいいのか、それはDIでnewをする。
それを解決するためにDIが必要。


## 4章 クリーンアーキテクチャとは何か

クリーンアーキテクチャは、理解しやすく、安定した構造でユニットテストがしやすいプログラムを作るためのアーキテクチャパターン。

- 同心円でレイヤーを構成する
- レイヤーの外側から、内側へのみ依存しても構わない（外側が内側を呼び出す）。内側から外側へは一切依存してはならない。一方通行にする。
- レイヤー間を行き来するデータは必ずプレインオブジェクトにすること
- レイヤーを行き来するデータは、必ず内側の知識のみで作ること
- 最も抽象度の高いものが一番内側に配置され、抽象度が低くなる、つまり詳細の実装になればなるほど外側に配置される
  - 一番内側はインティティ層
  - 二番目はユースケース層は、ドメイン知識・ビジネスロジックのみを書き込む。エンティティ層のみに依存可能。
  - 三番目のインターフェースアダプタ層では、ユースケース層とウェブAPIや各種システムコールなどをつなぎこむ変換層。
  - 外側のフレームワークドライバー層は普通は意識しない。

### レイヤー構造を取る


### MVC構造

M. データを取ってくるなど、ビジネスロジックを作る
V. 表示する
C. MとVをを実行する

