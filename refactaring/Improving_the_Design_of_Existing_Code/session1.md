# session1

## いいと思ったコード

### 0以上を加算する

```
voulumeCredits = Math.max(perf.audience -30, 0) // p.3
```

### if分のワンライナー

```
if (xxxx) yyyy // xxxxが正の時,yyyyを行う
```

### シャローコピー

Object.assign()は破壊的関数
```
result = Object.assign({}, aPerformance) // p.27
```

### パイプラインによるループの置き換え

```
const array1 = [1, 2, 3, 4];
const reducer = (accumulator, currentValue) => accumulator + currentValue;

// 1 + 2 + 3 + 4
console.log(array1.reduce(reducer));
// expected output: 10

// 5 + 1 + 2 + 3 + 4
console.log(array1.reduce(reducer, 5));
// expected output: 15
```

### 配列からオブジェクトへ

結構見やすくなるし、扱いやすくなる。
```
result.play = plays[aPerformance.playId]; // p.27
```

### Intl

金額関係をよしなにやってくれる
```
var number = 12345678;
console.log(new Intl.NumberFormat().format(number));
//  -> 12,345,678
```

```
var number = 5000;
console.log(new Intl.NumberFormat('ja-JP', { style: 'currency', currency: 'JPY' }).format(number));
//  -> ￥5,000
console.log(new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(number));
//  -> $5,000.00
```

### 全ての配列に同様の操作を行う

```
Array.map(callback);
```

## 重要なポイント

```
構造的に機能を加えにくいプログラムに新規機能を追加しなければならない場合には、
まずは機能追加が簡単になるようにリファクタリングをしてから追加する
```

```
リファクタリングに入る前にしっかりとしたテスト群を作成しておく。
これらのテストには自己診断機能が不可欠である。
```

```
リファクタリングでは小さなステップでプログラムを変更していく。そのためバグが見つかっても変更が用意である。
```

```
リファクタリングとパフォーマンスについて、もしリファクタリングでパフォーマンスが落ちたらチューニングする。
その場合もまずはリファクタリングを行う。そうすることでより良いチューニングを行うことができる。
```

## メモ

- 元の関数をコピーして少しの変更を加えることがあるが、これは元の関数に変更を加える場合に、コピーした関数にも変更を加える必要があるため、あまり適切ではない。
- 値を変更する変数: 関数にした時に入力と出力で値が異なる変数
- 小さな変更とテスト: 小さな変更ごとにテストを行って間違いがないかを測る
- 小さな変更のテストが通ったら、すかさずcommitすること
- 抽出された関数を手軽にわかりやすくする方法は変数名を変えること（これは関数に限らない）
- 一時変数があるとローカル変数が多くなり抽出が面倒になるので積極的に置き換える
- トップレベルの関数: もっとも実行に呼び出し元に近い関数
- 一次関数を消していく、関数の抽出を行うことで構造化はだいぶましになる。ただ入れ子になった関数がたくさんになる。
- ヘルパー関数: トップレベル関数の中身を抽出した関数
- 構造化とは、関数の中身をヘルパー関数に抽出することで、論理的な部品としてわかりやすくするために関数を構造を加えること
- フェーズの分離: 関数の機能をフェーズ（段階）に分ける。
- 中間データ構造: フェーズの分離を行った関数の橋渡しをするデータ
- 関数に渡されたデータはできる限り、普遍を目指す（シャローコピーを活用する）
- イテレーターの中身は冠詞をつけることでわかりやすく表現することができる（ex. performances => aPerformance）

### 型による計算処理の再構成

- 関数内の条件を編集することで変更を加える -> 型によるポリフォーリズム
- コンテキスト = スコープ

## 流れ

1. 大きな関数の分割

- 関数の抽出
- 抽出した関数をわかり安くする(変数名を変えるが手っ取り早い,returnで返すものを`return`にする)
- 型の名前を引数に入れる。冠詞をつける
- 問い合わせの一時変数の置き換え
- 関数宣言の変更(パラメーターの削除)

2. フェーズの分離

- 計算とフォーマットのコードを分離
- ファイルの分離（モジュール化）

3. クラス化

- ポリフォーリズムを使い条件ごとに同じ動作をするコードを作る

## 使用したテクニック

### 論理的な部品として見やすくするために、関数に構造を与える
- ループの分離: 値の集計を分離するため
- ステートメント(文)のスライド: 初期化の処理を集計処理の直前に移動させるため
- 関数の抽出: 合計を計算する関数を定義するため
- 変数のインライン化: 変数を完全に削除するため

### ２つのファイル(フェーズ)への分離
関数が構造的になっているので、それぞれの機能をフェーズにわけ、ファイルを分割する。

### サブクラスによるタイプコードの置き換え

switch文やif文でロジック立てられたコードをサブクラスを使うことで置き換える。
javascriptではサブクラスでインスタンスを返せないため、 `ファクトリ関数によるコンストラクタの置き換え`を使う。
