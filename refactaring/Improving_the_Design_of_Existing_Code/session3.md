# 第３章 コードの不吉な匂い

リファクタリングを行うべきタイミングを匂いで表す。

## 不可思議な名前

関数、モジュール、変数、クラスなどの名前について、行なっていることや利用方法がはっきりと伝わるように懸命に考える。

- 関数宣言の変更
- 変数名の変更
- フィールド名の変更

## 重複したコード

重複部分を修正する場合は、重複部分を漏れなく見つけ、全てを同様に修正を施していく必要がある。
これはバグの温床になるので、一箇所にまとめる必要がある。

- 関数の抽出
- ステートメントのスライド: 類似コードを一つのところにまとめ、抽出しやすくする。
- メソッドの引き上げ: サブクラス間に重複したコードがある場合は、スーパークラスにまとめる。

## 長い関数

関数は長くなれば、長くなるほどわかりにくくなる。
しかし、関数の抽出を行うと関数を次から次へと追っていかねばなず、依然としてある種のオーバーヘッドがかかる。
そこで関数名を意識し、適切な名前をつけてあげれば、内部の実装をみることなく、先に読み進めていくことができる。

### 関数を減らす方法

- 関数の抽出: 人つにまとめられそうな箇所があったら迷わずまとめる

### パラメータリストを減らす

- 問い合わせによる一時変数の置き換え: パラメータや一時変数を次々と受け渡さないように、一時変数を減らす。
- パラメータオブジェクトの導入: パラメータリストを減らす
- オブジェクトそのものの受け渡し: パラメータリストを減らす
- コマンドによる関数の置き換え: 一時変数やパラメータを減らす強力な武器。

### 条件分岐やループの抽出

- 条件記述の分解
- 関数の抽出: 巨大なswitch文にも使える
- ポリモーフィズムによる条件記述の置き換え: 同じ条件で分岐しているswitch文が複数あった場合
- ループの分離: ループ部分とループ内部でコードを抽出することができる。

### 関数の名付け方

関数の名前をつけるときは、内部でどのような処理をしているのかではなく、そのコードが何をするのかという `意図`を示した名前をつけるようにします。

たとえコードが長くなってしまったとしても、意図が伝われば良しとする。

## 長いパラメータリスト

長いパラメータリストは混乱の元となるし、かといってグローバル変数もを使うのも同様に混乱の元となる。

- 問い合わせによるパラメータの置き換え: パラメータで渡されるオブジェクトに問い合わせる
- オブジェクトそのものの受け渡し: 元々のデータ構造をわたす
- フラグパラメータの削除: パラメータが振る舞いを変えるためのフラグとして使われている場合
- 関数群のクラスへの集約: 複数の関数が、パラメータで渡される値を共有しているときに使う。

## グローバルなデータ

どこからでも変更可能なデータはデータの汚染を生むので防ぐ。

- 変数のカプセル化

そのあとクラスやモジュール内部に移動させることで、直接参照できる箇所を限定して、スコープをできるだけ狭めてあげるのが良いでしょう。

## 変更不可なデータ

データの変更はしばしば予期せぬ結果や、厄介なバグを引き起こす。
バグを見つけにくい。関数型プログラミング言語は変数の値が変わることを禁じている。
しかし、関数型プログラミングはプログラミングの世界では比較的少数派で、大抵の開発者は変数の値が変わることを許容したプログラミング言語を使っている。

無制限なデータ更新に伴うリスクを軽減するために、できること。

- 変数のカプセル化: 全ての値の変更が特定の関数を通してのみ起こるようにできる。
- 変数の分離: 一つの変数が別の事項を表すために使われているときに、双方を分離する。
- ステートメントのスライドと関数の抽出: 更新処理のコードと副作用のないコードとを分離する。
- 問い合わせの更新と分離: 呼び出し側が本当に必要なとき以外は、副作用のあるコードを呼ばずに住むようにします。
- setterの削除: setterを読んでいる側を特定してから、変数のスコープを狭める
- 関数群のクラスへの集約と関数群の変数への集約: 変数の値を変更をしなければならない箇所を減らす。
- 参照からの値への変更: 部分的に内部の値を修正するよりは、全体を入れ替えてしまう。

## 変更の偏り

変更の偏りは、一つのモジュールが異なる目的のために異なる方法で変更される状況。

```
ex)
データベースが追加されるたびにいつもこの三つのメソッドを変更しなければならない、
金融商品が出るたびに毎回この四つのメソッドを修正しなけらばならない
```

金融商品とデータベースのやりとりは全く別のコンテキストにあるもの。
それぞれのコンテキストを別々のモジュールに移す。

- フェーズの分離: データベースからデータを取り出してから金融処理に利用するといった形で、二つの処理が順番にあわられるのが自然な場合に使う。

## 変数の分散

変更すべき箇所が全体に広がると探すのが難しくなり、重要な変更を実装し忘れる場合も出てきます。

- 関数の移動とフィールドの移動: 変更部分を一つのモジュールにまとめ上げるようにする。
- 関数群のクラスへの集約: 似たようなデータ構造を扱う一連の関数群がある場合にまとめる
- 関数群の変換への集約: データ構造を変換したり、情報を蒸したりする関数群がある場合に使う
- フェーズの分離: データを消費するロジックのために、共通の関数群が出力を組み合わせている場合に使う。

## 特性の横恋慕

プログラムとのモジュール化に当たっては、内部でのやりとりを最大に、外部とのやりとりを最小になるようにコードを分離しようとします。

特性の横恋慕とは、あるモジュールの関数が、内部のモジュールよりも、外部のモジュールの関数やデータ構造とやりとりしていることをさす。

- 関数の移動と関数の抽出と関数の移動: 関数内の一部のロジックだけ移動させる

### 関数が複数のモジュールのデータを参照している場合

大部分のデータを一部のモジュールに大部分のデータを移動させる。

## データの群れ

数個のデータがつるんで、クラスのフィールドやメソッドのシグニチャなど、様々な箇所に現れることがあります。
こうした群れをなしたデータは、同じ住処にまとめるべきです。

- クラスの抽出: データの群れをオブジェクトに発展に変える。
- パラメータオブジェクトの導入とオブジェクトそのものの受け渡し: パラメータリストを減らす

## 基本データ型への執着

組み込みデータ型に固執することなく適切な型を定義する。

- オブジェクトによるプリミティブな置き換え
- サブクラスによるタイプコードの置き換えとポリモーフィズムによる条件記述の置き換え: データが振る舞いを変えるための単純なタイプコード
- クラスの抽出とパラメータオブジェクトの導入: 基本データ型の同じ集まりが何度もコード中に現れている場合に使う

## 重複したスイッチ文

switch/case文やネストしたif/else文の形で、コードの様々な箇所に同じ条件分技ロジックが書かれていればそれは不吉な匂い。

重複した条件分技が問題なのは、新たに分技を追加したら、全ての重複した条件分技を探して更新していかなければならないからです。

ポリモーフィズムは、そうした単調な繰り返しに誘うダークフォースに対抗するための、洗練された武器です。

## ループ

プログラミング言語の
